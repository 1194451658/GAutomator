<!DOCTYPE html>
<html>
<head>
<title>GAutomator使用说明文档(Unreal4)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<p><a name="GAutomator"></a></p>
<h2>GAutomator Unity自动化测试教程</h2>
<ul>
<li><a href="#1">1 准备工作</a>
<ul>
<li><a href="#1.1">1.1 介绍</a></li>
<li><a href="#1.2">1.2 环境</a></li>
<li><a href="#1.3">1.3 使用脚本</a></li>
<li><a href="#1.4">1.4 GAutomatorView</a></li>
</ul>
</li>
<li><a href="#2">2 Getting</a>
<ul>
<li><a href="#2.1">2.1 Simple</a></li>
<li><a href="#2.2">2.2 实例详解</a></li>
<li><a href="#2.3">2.3 wetest云端兼容测试</a></li>
<li><a href="#2.4">2.4 本地运行</a></li>
</ul>
</li>
<li><a href="#3">3 Locating</a>
<ul>
<li><a href="#3.1">3.1 find_element</a></li>
<li><a href="#3.2">3.2 节点位置查找</a>
<ul>
<li><a href="#3.2.1">3.2.1 节点在屏幕上的位置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4">4 交互</a>
<ul>
<li><a href="#4.1">4.1 点击操作</a></li>
<li><a href="#4.2">4.2 long</a></li>
<li><a href="#4.3">4.3 swipe滑动</a></li>
<li><a href="#4.4">4.4 获取文字内容</a></li>
</ul>
</li>
<li><a href="#5">5 Mobile设备</a>
<ul>
<li><a href="#5.1">5.1 屏幕尺寸与转向</a></li>
<li><a href="#5.2">5.2 顶层Package与Activity</a></li>
<li><a href="#5.3">5.3 回退键</a></li>
</ul>
</li>
<li><a href="#6">6 云端报告</a>
<ul>
<li><a href="#6.1">6.1 截图与操作过程标记</a></li>
<li><a href="#6.2">6.2 截图</a></li>
<li><a href="#6.3">6.3 打标签</a></li>
<li><a href="#6.4">6.4 报告错误</a></li>
</ul>
</li>
<li><a href="#7">7 实战用例</a>
<ul>
<li><a href="#7.1">7.1 记录操作流程</a></li>
<li><a href="#7.2">7.2 QQ或微信登录</a></li>
<li><a href="#7.3">7.3 异常处理</a></li>
</ul>
</li>
<li><a href="#8">8 实际使用接口</a>
<ul>
<li><a href="#8.1">8.1 screen_shot_click</a></li>
<li><a href="#8.2">8.2 screen_shot_click_pos</a><br>
<strong>GAutomator</strong> 通过Python实现Unity手游的UI自动化测试，强烈建议使用pycharm编辑python。可在bin目录下包含所有需要的组件。</li>
</ul>
</li>
</ul>
<p><a name="注："></a></p>
<h3>注： GAutomator UE4版本，需要把config.py中的EngineType修改为Engine.UE4，默认为Unity</h3>
<p><a name="1"></a></p>
<h1>1 准备工作</h1>
<p><a name="1.1"></a></p>
<h2>1.1 介绍</h2>
<p>通过Python实现Unreal 4手游的UI自动化测试。GAutomator测试运行在手机端，通过adb操控手机上的UE4手游，支持所有版本的Android手机。这个工具的主要功能包括：测试与Android手机之间的兼容性--测试手游在不同Android手机上的工作情况。功能性测试，PVP游戏可以自动化测试代替人力节省操作，PVE游戏可以自动大关完成冒烟测试。性能测试，云端测试能够手机CPU、内存、流量和FPS数据，能够标记不同的场景。</p>
<p><a name="1.2"></a></p>
<h2>1.2 环境</h2>
<p><strong>1 python</strong>: python 2.7</p>
<p><strong>2 adb</strong><br>
请确保，你的path环境变量里面设置了adb<br>
在cmd命令行里面输入adb devices，能够看到你的手机序列号</p>
<p><a name="1.3"></a></p>
<h2>1.3 使用脚本</h2>
<p>如果使用pycharm的话，直接打开scripts功能即可进行编辑使用</p>
<p><a href="image/pycharm_step1.png" target="_blank"><img src="image/pycharm_step1.png" alt="Drawing" width="300px" style="max-width:100%;"></a></p>
<p><a href="image/pycharm_step2.png" target="_blank"><img src="image/pycharm_step2.png" alt="Drawing" width="300px" style="max-width:100%;"></a></p>
<p>可以在testcase目录下面直接创建你需要的.py脚本，然后编写需要的逻辑</p>
<p><a name="1.4"></a></p>
<h2>1.4 GAutomatorView</h2>
<p>GAutomatorView工具可在<a href="http://wetest.qq.com/cloud/index.php/phone/blrooike%E4%B8%8B%E8%BD%BD" rel="nofollow">http://wetest.qq.com/cloud/index.php/phone/blrooike下载</a> 。GAutomator主要根据，Unity游戏中的GameObject的路径名称来编写逻辑。类似于UIAutomator需要有一个，控件查看器；GAutomator也提供了一款类似的，Unity游戏中控件查看器。<br>
<strong>注：请勿将该软件放置在中文目录下</strong></p>
<p><a href="image/behaviour.png" target="_blank"><img src="image/behaviour.png" alt="Drawing" width="800px" style="max-width:100%;"></a></p>
<p>集成wetest sdk的游戏拉起后，点击同步按钮，就能获取到游戏界面和控件树</p>
<p><a name="2"></a></p>
<h1>2 Getting Started</h1>
<p>示例代码：sample/sample.py,示例apk游戏:sampel/wetest_demo_ue.apk<br>
<a name="2.1"></a></p>
<h2>2.1 Simple Usage</h2>
<p>已经安装好python及依赖库后，可以使用pycharm（请下社区版，社区版免费）直接打开工程，你可以下面的代码开始我们的测试</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">&lt;</span>a name<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>lib<span class="pl-pds">"</span></span><span class="pl-k">&gt;&lt;</span><span class="pl-k">/</span>a<span class="pl-k">&gt;</span>

<span class="pl-c"><span class="pl-c">#</span>import lib path,only use in this demo</span>
<span class="pl-c"><span class="pl-c">#</span>import sys,os</span>
<span class="pl-c"><span class="pl-c">#</span>sys.path.append(os.path.abspath(os.path.join(os.getcwd(), "..\\")))</span>

<span class="pl-k">import</span> wpyscripts.manager <span class="pl-k">as</span> manager

<span class="pl-k">def</span> <span class="pl-en">test</span>():
    version <span class="pl-k">=</span> engine.get_sdk_version()
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Version Information : <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(version))

    scene <span class="pl-k">=</span> engine.get_scene()
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Scene :   <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(scene))

    sample_button <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Sample<span class="pl-pds">"</span></span>)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(sample_button))
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button Bound: <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(engine.get_element_bound(sample_button)))
    screen_shot_click(sample_button)

test()
</pre></div>
<p>上面的代码可以保存为sample.py,然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python samle.py</pre></div>
<p>请确保，wetestdemo游戏已经拉起，GAutomator库能够查找到</p>
<p><a name="2.2"></a></p>
<h2>2.2 实例详解</h2>
<p>wpyscripts.manager模块提供了自动化测试所需的所有功能，提供与引擎、手机、报告相关的内容，也提供了日志实现</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> wpyscripts.manager <span class="pl-k">as</span> manager</pre></div>
<p>下一步，创建Engine和日志实例</p>
<div class="highlight highlight-source-python"><pre>engine<span class="pl-k">=</span>manager.get_engine()
logger<span class="pl-k">=</span>manager.get_logger()</pre></div>
<p>*<code>engine.get_sdk_version()</code>*能够获取Unity版本信息、Wetest sdk版本信息，能够获取该信息时，证明脚本已经成功连上游戏。如果获取失败，则会抛出<code>WeTestNativeEngineDllError</code>异常,抛出该异常可能是手机USB线没有连好或者手机开发者选项未打开。<br>
*logger.debug("")*输出对应日志，请使用manager.get_logger()获取的实例，避免脚本在云端<a href="http://wetest.qq.com" title="wetest" rel="nofollow">wetest.qq.com</a>使用时出错。</p>
<div class="highlight highlight-source-python"><pre>version<span class="pl-k">=</span>engine.get_sdk_version()
logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Version Information : <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(version))</pre></div>
<p>*<code>engine.get_scene()</code>*获取当前游戏界面对应地图(Level关卡)名称</p>
<p>*<code>engine.find_element("Sample")</code>*查找当前界面中路径为Sample的节点，如果存在则返回Element，不存在则返回None。当前节点返回的仅为UMG的节点信息，UMG的节点名称唯一，因此find_element仅传节点名称即可。<br>
查找到的节点samle_button（<em>Element</em>），有两个属性object_name,instance。object_name代表的是节点的名称，在UMG中该节点名称一定唯一。<br>
*<code>engine.click(sample_button)</code>*尝试点击samle_button这个UObject的中心点。</p>
<div class="highlight highlight-source-python"><pre>sample_button<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Sample<span class="pl-pds">"</span></span>)
logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(sample_button))
engine.click(sample_button)</pre></div>
<p>GAutomator包含3大接口</p>
<div class="highlight highlight-source-python"><pre>engine<span class="pl-k">=</span>manager.get_engine()
reporter<span class="pl-k">=</span>manager.get_reporter()
device<span class="pl-k">=</span>manager.get_devcie()</pre></div>
<ul>
<li>engine:Unity相关内容，主要包括控件获取，游戏操作。<strong>Unity与UE4 engine的接口不一致，具体详见文档</strong>。GAutomator根据配置，选择对应的实现，Unity引擎实现为UnityEngine类，<strong>UE4引擎为UnRealEngine类</strong></li>
<li>reporter:云端报告相关，截图、标记操作过程、性能数据打标签</li>
<li>device:手机设备相关，如屏幕长宽高、转向，也包括QQ登录等。</li>
</ul>
<p><a name="2.3"></a></p>
<h2>2.3 wetest云端兼容测试</h2>
<p>GAutomator编写好的测试脚本，只需要非常简单的修改，就能wetest云端上做兼容测试。云端几千台手机，按照脚本执行游戏。wetest能够发现兼容问题，同时高度还原执行现场，包括手机日志、崩溃信息、截图、执行过程等。</p>
<p>云端执行脚本时，会执行testcase.runner下的run函数，只需要把自己的业务逻辑加入到这个函数中即可</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> traceback

<span class="pl-k">try</span>:
    <span class="pl-k">from</span> sample.sample <span class="pl-k">import</span> <span class="pl-k">*</span>
<span class="pl-k">except</span> <span class="pl-c1">Exception</span>,e:
    traceback.print_exc()

<span class="pl-k">def</span> <span class="pl-en">run</span>():
    <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">        业务逻辑的起点</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    <span class="pl-k">try</span>:
        test()
    <span class="pl-k">except</span> <span class="pl-c1">Exception</span>,e:
        traceback.print_exc()</pre></div>
<p>然后，运行scripts目录下的，build.py<br>
<code>python build.py</code><br>
会在scripts目录下产生一个,wpyscripts_upload.zip。只有企业用户才可以使用云端测试，请登录wetest.qq.com，联系工作人员了解详情。</p>
<p><a href="image/step1.png" target="_blank"><img src="image/step1.png" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a href="image/step2.png" target="_blank"><img src="image/step2.png" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a href="image/step3.png" target="_blank"><img src="image/step3.png" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a name="2.4"></a></p>
<h2>2.4 本地运行</h2>
<p><strong>注：调试时手动启动游戏，运行到指定界面，运行对应的脚本即可，如调试大厅界面的代码，游戏跑到大厅界面，再运行自动化测试逻辑。不需要从main.py启动</strong><br>
GAutomator支持一台PC在多台android手机上同时测试。在config.py文件中，可以配置，完成单台手机测试的情况。<br>
<strong>测试的游戏包名</strong></p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">TestInfo</span>(<span class="pl-c1">object</span>):
    <span class="pl-c1">PACKAGE</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>com.tencent.wetest.demo<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span> 测试包名</span></pre></div>
<p><strong>测试账号</strong></p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">Account</span>(<span class="pl-c1">object</span>):
    <span class="pl-c1">QQNAME</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span>QQ账号</span>
    <span class="pl-c1">QQPWD</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span>QQ密码</span>
    <span class="pl-c1">WECHATNAME</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span>微信账号</span>
    <span class="pl-c1">WECHATPWD</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">#</span>微信密码</span>
</pre></div>
<p><strong>引擎选择（默认为Unity)</strong><br>
UE4用户一定要配置为UE4</p>
<pre><code>&lt;a name="Engine"&gt;&lt;/a&gt;

### Engine Type
Unity="unity"
UE4="ue4"

class Engine(object):
    Type=UE4 #Type="unity" # unity or ue4
</code></pre>
<p>一般一个工程通过main方式启动，只能测试一个游戏，所以直接在main.py里面写死，也避免参数传入的麻烦。<br>
1、测试一台手机，如果PC上USB只连接一台手机，直接启动main.py即可(前提配置好测试包名)</p>
<div class="highlight highlight-source-batchfile"><pre>python main.py</pre></div>
<p>2、测试多台手机，如果PC上USB连接超过一台手机，需要通过命令行的方式启动</p>
<div class="highlight highlight-source-batchfile"><pre>adb devices #查看当前手机序列号

saaaweadf        device
asdfadfadf		 device
</pre></div>
<p>获取到当前PC连接的手机序列号之后，通过命令行的方式控制脚本在指定的手机上进行测试。</p>
<div class="highlight highlight-source-batchfile"><pre>python main.py --qqname=<span class="pl-c1">2952020110</span> --qqpwd=wetestpwd --engineport=<span class="pl-c1">50031</span> --uiport=<span class="pl-c1">19000</span> --serial=saaaweadf
python main.py --qqname=<span class="pl-c1">2952020111</span> --qqpwd=wetestpwd --engineport=<span class="pl-c1">50032</span> --uiport=<span class="pl-c1">19001</span> --serial=asdfadfadf</pre></div>
<p>上面的命令分别代表，在序列号"saaaweadf"手机上测试，测试时使用的QQ号为2952020110,密码为wetestpwd，与引擎建立映射的网络端口号为50031,与UIAutomator服务建立映射的网络端口为19000。第二条命令类似。</p>
<p><strong>命令行参数含义</strong>如下：</p>
<div class="highlight highlight-source-batchfile"><pre>--qqname:qq账号，每部手机应该都不一样
--qqpwd:qq密码
--wechataccount:微信账号
--wechatpwd:微信密码
--othername:其他任何账号
--otherpwd:其他任何账号的密码
--engineport:与手机端的sdk服务建立网络映射，填入的为本地的网络端口号（如,50031），不同手机之间要确保不同
--uiport:与手机端的UIAutomator服务建立网络映射，填入的为本地的网络端口号（如,19008），不同手机之间要确保不同
--serial:adb devcies能够查看手机的序列号，不同的序列号代表不同的手机</pre></div>
<p><a name="3"></a></p>
<h1>3 Locating Elements</h1>
<p>UE4目前版本仅支持UMG控件的查找与操作<br>
engine模块提供了一种UI控件的查找方式。示例：sample/UE4/find_elements.py</p>
<ul>
<li><em>find_element</em></li>
</ul>
<p><a name="3.1"></a></p>
<h2>3.1 find_element</h2>
<p><em>find_element</em>通过Unity的GameObject.Find()方法查找游戏中的的gameobject。<em>find_element</em>通过GameObject的名称查找对象，名字中可以包含'/'代表GameObject树中的一层。这方法只返回当前激活(active)的gameobject。<br>
当界面上有两个一模一样路径的gameobject时，只返回其中的一个。代码示例：</p>
<div class="highlight highlight-source-python"><pre><span class="pl-c"><span class="pl-c">#</span>import sys,os,time</span>
<span class="pl-c"><span class="pl-c">#</span>sys.path.append(os.path.abspath(os.path.join(os.getcwd(), "..","..")))</span>

<span class="pl-k">def</span> <span class="pl-en">test_find_element</span>():
    <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">        使用engine.find_element查找游戏中的节点</span>
<span class="pl-s">    :return:</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    button <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Button_0<span class="pl-pds">"</span></span>)
    bound <span class="pl-k">=</span> engine.get_element_bound(button)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(button, bound))
    engine.click(button)

    button <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Button_1<span class="pl-pds">"</span></span>)
    bound <span class="pl-k">=</span> engine.get_element_bound(button)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(button, bound))
    engine.click(button)

    unexited_gameobj <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Test<span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> unexited_gameobj <span class="pl-k">is</span> <span class="pl-c1">None</span>:
        logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Test GameObject not find<span class="pl-pds">"</span></span>)

test_find_element()</pre></div>
<p>上面的代码可以保存为find_elments.py,从wetest_demo_ue点击FindElements，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python find_elments.py</pre></div>
<p>UE4的UMG中UI控件的名称一定是唯一的，可以作为标识存在。如果查找的名称存在则返回Element，如果不存在则返回None</p>
<p><a name="3.2"></a></p>
<h2>3.2 节点位置查找</h2>
<p><a name="3.2.1"></a></p>
<h3>3.2.1 节点在屏幕上的位置</h3>
<p>*engine.get_element_bound(element)*能够获取节点在屏幕中的位置。GAutomator所有的操作都是通过触屏进行的，因此获取节点在屏幕上的位置是进行交互操作的基石。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_click</span>():
    <span class="pl-c"><span class="pl-c">#</span> 点击节点</span>
    element <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>ClickBtn<span class="pl-pds">"</span></span>)
    bound <span class="pl-k">=</span> engine.get_element_bound(element)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(element, bound))

    engine.click(bound)
    time.sleep(<span class="pl-c1">1</span>)
    engine.click(element)

    <span class="pl-c"><span class="pl-c">#</span> 点击坐标</span>
    time.sleep(<span class="pl-c1">2</span>)
    engine.click_position(<span class="pl-c1">600.0</span>, <span class="pl-c1">100.0</span>)

test_click()</pre></div>
<pre><code>[{u'existed': True, u'width': 200.688, u'visible': True, u'height': 99.9, u'instance': 0, u'path': u'ClickBtn', u'y': 140.4, u'x': 552.796}]
</code></pre>
<p><code>engine.get_element_bound(Element)</code>获取的是ElementBound，获取Element的左上角在屏幕上的坐标，和Element的长宽高。遵循的是手机的坐标系，以左上角为坐标原点，上下边框为width，左右为height。</p>
<p><a href="image/interaction_click.png" target="_blank"><img src="image/interaction_click.png" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a href="image/portrait.png" target="_blank"><img src="image/portrait.png" alt="Drawing" width="300px" style="max-width:100%;"></a></p>
<p><a name="4"></a></p>
<h1>4 交互</h1>
<p>找到节点后的第一件后，就需要对寻找到的节点进行操作。示例：sample/interaction.py</p>
<div class="highlight highlight-source-python"><pre>engine.click(button)</pre></div>
<p>Engine执行操作后，会等到操作执行完成后才会返回。engine.click(Element)返回为True的话，只保证执行了button中心点的点击事件，不能确保button对应的事件被有效执行（有弹出框，遮住的情况就可能使点击无效）。</p>
<p><a href="image/interaction_mask.png" target="_blank"><img src="image/interaction_mask.png" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a name="4.1"></a></p>
<h2>4.1 点击操作</h2>
<p>*engine.click()*允许传入Element和ElementBound。如果传入的是Element，会先去查找ElementBound,然后再计算出节点的中心位置进行点击。所以，在有ElementBound的情况下，应该首先传入ElementBound。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_click</span>():
    <span class="pl-c"><span class="pl-c">#</span>点击节点</span>
    element <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>ClickBtn<span class="pl-pds">"</span></span>)
    bound<span class="pl-k">=</span>engine.get_element_bound(element)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Button : <span class="pl-c1">{0}</span>,Bound : <span class="pl-c1">{1}</span><span class="pl-pds">"</span></span>.format(element,bound))

    engine.click(bound)
    time.sleep(<span class="pl-c1">1</span>)
    engine.click(element)

    time.sleep(<span class="pl-c1">2</span>)
    engine.click_position(<span class="pl-c1">600.0</span>,<span class="pl-c1">100.0</span>)

test_click()</pre></div>
<p>上面的代码可以保存为interaction.py,从wetestdemo点击Interaction，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python interaction.py</pre></div>
<p>程序会连续点击3下，Click按钮。</p>
<ul>
<li><code>engine.click(bound)</code>会点击，Click的中心节点(point.x+withd/2,point.y+height/2)</li>
<li><code>engine.click(element)</code>首先回去查找element节点的ElementBound，然后计算出中心点，在进行点击</li>
<li><code>engine.click_position(600.0,100.0)</code>直接点击屏幕坐标为(600.0,100.0)的坐标。<strong>手机屏幕尺寸发生变化，点击将无效，不能点击到期望位置</strong></li>
</ul>
<p><a name="4.2"></a></p>
<h2>4.2 long press长按</h2>
<p><em>engine.press()和engine.press_position</em>与click相似，多一个时间参数，表示长按的时间（单位ms,毫秒）</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_press</span>():
    element<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>PressBtn<span class="pl-pds">"</span></span>)
    engine.press(element,<span class="pl-c1">5000</span>)
    time.sleep(<span class="pl-c1">2</span>)
    engine.press_position(<span class="pl-c1">1200</span>,<span class="pl-c1">100</span>,<span class="pl-c1">3000</span>)
    
test_press()</pre></div>
<p>上面的代码可以保存为interaction.py,从wetestdemo点击Interaction，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python interaction.py</pre></div>
<ul>
<li><code>engine.press(element,5000)</code>,<code>PressBtn</code>节点连续按住5s</li>
<li><code>ngine.press_position(1200,100,3000)</code>,(1200,100)点，连续按住3s</li>
</ul>
<p><a name="4.3"></a></p>
<h2>4.3 swipe滑动</h2>
<p><em>engine.swipe(start_element, end_element, steps, duration=1000)和engine.swipe_position(start_x,start_y,end_x,end_y, duration=1000)</em>，可以从一个节点滑动到另外一个节点。duration以毫秒为单位，为滑动的时长。滑动时长不能不能精确控制，只是尽可能接近。。<em>swipe与swipe_position</em>动作执行完之后返回，由SDK负责执行动作，不能并行的执行动作。如下面的示例中，第一个动作执行完后，才会执行第二个动作。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_swipe</span>():
    start_e <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>ClickBtn<span class="pl-pds">"</span></span>)
    end_e <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>PressBtn<span class="pl-pds">"</span></span>)
    engine.swipe(start_e, end_e,<span class="pl-c1">2000</span>)

    time.sleep(<span class="pl-c1">5</span>)

    silder <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Slider_0<span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> silder:
        bound <span class="pl-k">=</span> engine.get_element_bound(silder)
        engine.swipe_position(bound.x<span class="pl-k">+</span><span class="pl-c1">3</span>, bound.y <span class="pl-k">+</span> bound.height <span class="pl-k">/</span> <span class="pl-c1">2.0</span>, bound.x <span class="pl-k">+</span> bound.width, bound.y <span class="pl-k">+</span> bound.height <span class="pl-k">/</span> <span class="pl-c1">2</span>,<span class="pl-c1">3000</span>)
test_swipe()</pre></div>
<p>上面的代码可以保存为interaction.py,从wetest_demo_ue点击Interaction，然后运行</p>
<div class="highlight highlight-source-batchfile"><pre>python interaction.py</pre></div>
<p>从Press的中心点按钮按下，一直Move到Click的中心点，中间经过50步，最后执行Up动作，持续时长大致为2秒</p>
<pre><code>start_e = engine.find_element("ClickBtn")
end_e = engine.find_element("PressBtn")
engine.swipe(start_e, end_e,2000)
</code></pre>
<p>无论swipe的步长设置为多少，都会立刻返回。立刻执行swipe_position函数，swipe_position也需要动作执行完之后才会返回，但是游戏中还不会马上执行这个动作。需要swipe执行完成后，才会执行swipe_position的动作。</p>
<pre><code> silder = engine.find_element("Slider_0")
    if silder:
        bound = engine.get_element_bound(silder)
        engine.swipe_position(bound.x+3, bound.y + bound.height / 2.0, bound.x + bound.width, bound.y + bound.height / 2,3000)
</code></pre>
<p><a name="4.4"></a></p>
<h2>4.4 获取文字内容</h2>
<p>可以获取到游戏中的文字内容。NGUI能够获取到UILable、UIInput、GUIText组件上的文字内容，如果GameObject上不包含以上组件，将抛出异常。UGUI能够获取Text、GUIText组件上的文字信息。示例在interaction.py中，wetest_demo.apk需要在interaction界面。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_get_element_txt</span>():
    e<span class="pl-k">=</span>engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Click/Text<span class="pl-pds">"</span></span>)
    text<span class="pl-k">=</span>engine.get_element_text(e)
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Text = <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(text))</pre></div>
<p>上面的代码在sample/interaction.py中，运行该函数可以获取文字内容"Click"</p>
<p><a name="5"></a></p>
<h1>5 Mobile设备</h1>
<p>*engine.get_device()*类device提供与手机相关信息的API，也提供简单的操作。示例：sample/devices_tester.py</p>
<p><a name="5.1"></a></p>
<h2>5.1 屏幕尺寸与转向</h2>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_get_display_size</span>():
    display_size<span class="pl-k">=</span>device.get_display_size()
    logger.debug(display_size)

    rotation<span class="pl-k">=</span>device.get_rotation()
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Rotation : <span class="pl-c1">{0}</span><span class="pl-pds">"</span></span>.format(rotation))

test_get_display_size()
</pre></div>
<p>获取屏幕尺寸，DisplaySize类包括width、height单位为px。</p>
<p><a href="image/device_screen.png" target="_blank"><img src="image/device_screen.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
<p><a name="5.2"></a></p>
<h2>5.2 顶层Package与Activity</h2>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_get_top_package_activity</span>():
    top_activity<span class="pl-k">=</span>device.get_top_package_activity()
    logger.debug(top_activity)

test_get_top_package_activity()
</pre></div>
<p>上面的代码可以保存为devices_tester.py,再任意界面启动</p>
<div class="highlight highlight-source-batchfile"><pre>python devices_tester.py</pre></div>
<p>*device.get_top_package_activity()*获取手机当前界面的TopActivity对象，包含顶层app的包名和Activity名称。</p>
<pre><code>package name = com.tencent.wetest.demo,activity = com.unity3d.player.UnityPlayerActivity
</code></pre>
<p><a name="5.3"></a></p>
<h2>5.3 回退键</h2>
<p>GAutomator本身不提供对标准Android控件的支持，所以当界面上出现标准控件时将无法进行操作。因此，提供了回退（Back）操作，返回到游戏Activity。</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">test_back</span>():
    device.back()
test_back()</pre></div>
<p>上面的代码可以保存为devices_tester.py,再任意界面启动</p>
<div class="highlight highlight-source-batchfile"><pre>python devices_tester.py</pre></div>
<p>*device.back()*与按Android的回退键效果一致。</p>
<p><a name="6"></a></p>
<h1>6 云端报告</h1>
<p>*engine.get_reporter()*获取的Reporter类封装了与云端报告相关的内容，本地实现为空，只有在云端运行的时候才会有效果。游戏自动化测试过程中需要保持测试现场，所以在云端运行过程中需要标记测试过程和截图。Reporter主要负责与功能</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> sys, os, time

<span class="pl-c"><span class="pl-c">#</span>sys.path.append(os.path.abspath(os.path.join(os.getcwd(), "..\\")))</span>

<span class="pl-k">import</span> wpyscripts.manager <span class="pl-k">as</span> manager

engine <span class="pl-k">=</span> manager.get_engine()
logger <span class="pl-k">=</span> manager.get_logger()
reporter <span class="pl-k">=</span> manager.get_reporter()


<span class="pl-k">def</span> <span class="pl-en">screen_shot_click</span>(<span class="pl-smi">element</span>):
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>screen_shot_click<span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> element <span class="pl-k">is</span> <span class="pl-c1">None</span>:
        <span class="pl-k">return</span>
    bound <span class="pl-k">=</span> engine.get_element_bound(element)
    logger.debug(bound)
    pos_x <span class="pl-k">=</span> bound.x <span class="pl-k">+</span> bound.width <span class="pl-k">/</span> <span class="pl-c1">2</span>
    pos_y <span class="pl-k">=</span> bound.y <span class="pl-k">+</span> bound.height <span class="pl-k">/</span> <span class="pl-c1">2</span>
    reporter.capture_and_mark(pos_x, pos_y, <span class="pl-v">locator_name</span><span class="pl-k">=</span>element.object_name)
    engine.click_position(pos_x, pos_y)


<span class="pl-k">def</span> <span class="pl-en">enter_find_elmeents</span>():
    find_elements_button <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>FindElements<span class="pl-pds">"</span></span>)
    logger.debug(find_elements_button)
    screen_shot_click(find_elements_button)
    time.sleep(<span class="pl-c1">1</span>)


<span class="pl-k">def</span> <span class="pl-en">back_main</span>():
    find_elements_button <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>Back<span class="pl-pds">"</span></span>)
    logger.debug(find_elements_button)
    screen_shot_click(find_elements_button)
    time.sleep(<span class="pl-c1">1</span>)


<span class="pl-k">def</span> <span class="pl-en">test_capture_and_mark</span>():
    <span class="pl-k">for</span> index <span class="pl-k">in</span> <span class="pl-c1">range</span>(<span class="pl-c1">1</span>,<span class="pl-c1">6</span>):
        name<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>level<span class="pl-c1">{0}</span>Btn<span class="pl-pds">"</span></span>.format(index)
        e<span class="pl-k">=</span>engine.find_element(name)
        screen_shot_click(e)


<span class="pl-k">def</span> <span class="pl-en">test_reporter</span>():
    enter_find_elmeents()
    time.sleep(<span class="pl-c1">2</span>)
    reporter.add_start_scene_tag(<span class="pl-s"><span class="pl-pds">"</span>Find_Scene<span class="pl-pds">"</span></span>)
    test_capture_and_mark()
    reporter.add_end_scene_tag(<span class="pl-s"><span class="pl-pds">"</span>Find_Scene<span class="pl-pds">"</span></span>)
    time.sleep(<span class="pl-c1">2</span>)
    back_main()
    reporter.screenshot()
</pre></div>
<p>runner.py里面，调用test_reporter()。上传到平台后的结果的运行结果（同事在几百台手机上运行）</p>
<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> traceback

<span class="pl-k">try</span>:
    <span class="pl-k">from</span> sample.reporter_tester <span class="pl-k">import</span> <span class="pl-k">*</span>
<span class="pl-k">except</span> <span class="pl-c1">Exception</span>,e:
    traceback.print_exc()

<span class="pl-k">def</span> <span class="pl-en">run</span>():
    <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">        业务逻辑的起点</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    <span class="pl-k">try</span>:
        test_reporter()
    <span class="pl-k">except</span> <span class="pl-c1">Exception</span>,e:
        traceback.print_exc()
        stack<span class="pl-k">=</span>traceback.format_exc()
        logger.debug(stack)</pre></div>
<p><a href="image/reporter_screen.png" target="_blank"><img src="image/reporter_screen.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
<p><a href="image/reporter_perform.png" target="_blank"><img src="image/reporter_perform.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
<p><a name="6.1"></a></p>
<h2>6.1 截图与操作过程标记</h2>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">screen_shot_click</span>(<span class="pl-smi">element</span>):
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>screen_shot_click<span class="pl-pds">"</span></span>)
    <span class="pl-k">if</span> element <span class="pl-k">is</span> <span class="pl-c1">None</span>:
        <span class="pl-k">return</span>
    bound <span class="pl-k">=</span> engine.get_element_bound(element)
    logger.debug(bound)
    pos_x <span class="pl-k">=</span> bound.x <span class="pl-k">+</span> bound.width <span class="pl-k">/</span> <span class="pl-c1">2</span>
    pos_y <span class="pl-k">=</span> bound.y <span class="pl-k">+</span> bound.height <span class="pl-k">/</span> <span class="pl-c1">2</span>
    reporter.capture_and_mark(pos_x, pos_y, <span class="pl-v">locator_name</span> <span class="pl-k">=</span> element.object_name)
    engine.click_position(pos_x, pos_y)</pre></div>
<p>*reporter.capture_and_mark(pos_x, pos_y, locator_name = element.object_name)*将会截取当前手机屏幕，并在pos_x,pos_y位置标记一个红点。</p>
<p><a href="image/screen_mark.jpg" target="_blank"><img src="image/screen_mark.jpg" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a name="6.2"></a></p>
<h2>6.2 截图</h2>
<p>*reporter.screenshot()*在云端会截图在报告里面体现，在本地运行时会截图并放在运行目录下的screenshot目录下面。</p>
<p><a name="6.3"></a></p>
<h2>6.3 打标签</h2>
<div class="highlight highlight-source-python"><pre>reporter.add_start_scene_tag(<span class="pl-s"><span class="pl-pds">"</span>Find_Scene<span class="pl-pds">"</span></span>)
reporter.add_end_scene_tag(<span class="pl-s"><span class="pl-pds">"</span>Find_Scene<span class="pl-pds">"</span></span>)</pre></div>
<p>*reporter.add_start_scene_tag("")和reporter.add_end_scene_tag("")*一定是成对出现的，先start然后end，里面的标签内容需要一样。</p>
<p><a href="image/tag.png" target="_blank"><img src="image/tag.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
<p><strong>注：配合engine.get_scene()效果更佳</strong></p>
<p><a name="6.4"></a></p>
<h2>6.4 报告错误</h2>
<p>GAutomator并不是使用常见的，unittest作为测试的底层框架，因此并无断言，无法做功能测试。report_error接口，可用于错误报告，并且在运行目录下生成一份_wetest_testcase_result.txt用户记录报告的内容。该文件的报告格式与unittest的测试报告格式一致，因此在云端测试时可现实具体的信息。</p>
<div class="highlight highlight-source-python"><pre>report.report_error(<span class="pl-s"><span class="pl-pds">"</span>testcase<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>content<span class="pl-pds">"</span></span>)
report.report_error(<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">"</span>report_test<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-k">u</span><span class="pl-pds">"</span>Report test error 中文<span class="pl-pds">"</span></span>)</pre></div>
<p>*reporter.report_error(name,message)*接口调用的过程中，会在日志中输出。脚本运行结束时，runner.run中，会调用_report_total(),将所有的判断结果输出到_wetest_testcase_result.txt中。除了输出message和test_case_name之外GAutomator还会加上调用堆栈。name的名称尽可能不重复。name与message传入的编码方式需要一致，如果存在中文的情况下必须要使用UTF-8编码格式。</p>
<p><a name="7"></a></p>
<h1>7 实战用例</h1>
<p>举例最常见的，较难处理的引用场景scripts/testcase/tools.py封装了，场景的使用场景</p>
<p><a name="7.1"></a></p>
<h2>7.1 记录操作流程</h2>
<p>自动化测试记录操作流程，有利于出现bug时定位和复现。所以原则上，应该记录每一步操作。tools.py里面封装了一个接口，能够在截图上标记点击的位置，然后执行点击操作，点击完成等待相应的时间。</p>
<ul>
<li>screen_shot_click(element,sleeptime)接口,传入需要点击的节点和点击后等待时间。</li>
</ul>
<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">screen_shot_click</span>(<span class="pl-smi">element</span>, <span class="pl-smi">sleeptime</span><span class="pl-k">=</span><span class="pl-c1">2</span>):
    <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">        点击，并标记红点。</span>
<span class="pl-s">    :param element: 需要点击的element</span>
<span class="pl-s">    :param sleeptime:</span>
<span class="pl-s">    :return:</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    <span class="pl-k">if</span> element <span class="pl-k">is</span> <span class="pl-c1">None</span>:
        <span class="pl-k">return</span>
    <span class="pl-k">try</span>:
        bound <span class="pl-k">=</span> engine.get_element_bound(element)
    <span class="pl-k">except</span> WeTestRuntimeError, e:
        bound <span class="pl-k">=</span> <span class="pl-c1">None</span>
    <span class="pl-k">if</span> <span class="pl-k">not</span> bound:
        <span class="pl-k">return</span>
    logger.debug(bound)
    pos_x <span class="pl-k">=</span> bound.x <span class="pl-k">+</span> bound.width <span class="pl-k">/</span> <span class="pl-c1">2</span>
    pos_y <span class="pl-k">=</span> bound.y <span class="pl-k">+</span> bound.height <span class="pl-k">/</span> <span class="pl-c1">2</span>
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>screen_shot_click_pos x = <span class="pl-c1">{0}</span>,y = <span class="pl-c1">{1}</span>,name = <span class="pl-c1">{2}</span><span class="pl-pds">"</span></span>.format(pos_x, pos_y, element.object_name))
    report.capture_and_mark(pos_x, pos_y, <span class="pl-v">locator_name</span><span class="pl-k">=</span>element.object_name)
    engine.click_position(pos_x, pos_y)

    time.sleep(sleeptime)</pre></div>
<p>传入的element为空或者element的位置找不到，则自动跳过。</p>
<div class="highlight highlight-source-python"><pre>qq_button <span class="pl-k">=</span> engine.find_element(<span class="pl-s"><span class="pl-pds">"</span>/BootObj/CUIManager/Form_Login/LoginContainer/pnlMobileLogin/btnGroup/btnQQ<span class="pl-pds">"</span></span>)
screen_shot_click(qq_button, <span class="pl-c1">6</span>)</pre></div>
<p><a name="7.2"></a></p>
<h2>7.2 QQ或微信登录</h2>
<p>QQ或者微信登录，设计到Activity的切换和Android标准控件的操作,操作过程复杂，但是相对较为固定。在云端运行时，每次拉起游戏之前，都会清理数据，所以每次都需要重新登录。每次登录的过程如下所示：</p>
<p><a href="image/login_step.png" target="_blank"><img src="image/login_step.png" alt="Drawing" width="600px" style="max-width:100%;"></a></p>
对应的处理代码如下所示：
```python
def login():
    # 步骤1，等待到达登录界面
    wait_for_scene("SceneName")
<pre><code># 选择QQ登陆
qq_button = find_elment_wait("/BootObj/Panel/btnQQ")
screen_shot_click(qq_button, 6)

#步骤2 ，等待进入QQ登录界面，packagename为com.tencent.mobileqq，如果是微信登录界面package为com.tencent.mm
wait_for_package("com.tencent.mobileqq")
device.login_qq_wechat_wait(120)
time.sleep(10)

#步骤3，等待QQ登录界面退出，切换到游戏界面
select_btn = find_elment_wait("/BootObj/Panle/selectBtn")
</code></pre>
<pre><code>1. 步骤1：等待进入到登录选择scene，如何获取scene名称，请看[1.4 GAutomatorView](#1.4)。wait_for_scene("SceneName")，会一直查询，直到进入名称为"SceneName"的场景。进入到"SceneName"的场景后，查询QQ登录按钮直到出现(find_elment_wait)，并点击QQ登录按钮。
2. 步骤2：从游戏的Activity切换到QQ或者微信的登录界面需要一定的时间。`wait_for_package("com.tencent.mobileqq")`检查顶层包名，直到QQ的顶层包名(微信包名为com.tencent.mm)。`device.login_qq_wechat_wait(120)`会根据当前的顶层包名，自动选择QQ或者微信登录，当顶层包名不再是"com.tencent.mm"或"com.tencent.mobileqq"时推出。
**注：账号由云端自动分配。本地调试时请修改wpyscripts/wetest/device.py下面`native_deivce.__init__(self)`中的账号密码**
3. 步骤3：等待进入游戏界面，直到出现某个element为止。


&lt;a name="7.3"&gt;&lt;/a&gt;

## 7.3 异常处理
对于GAutomator的异常处理是一件非常头痛的事情，在设计框架的过程中也是左右为难，本质原因在于手机的端的不稳定性。不稳定主要包括以下几方面：
1. adb不稳定:windows的adb及其不稳定长期连接过程中不可避免的会出现断开连接的情况。出现断开的情况在腾讯可能有应用宝tadb.exe端口抢占、IOA、QQ浏览器及其他所有手机助手。wetest平台重写了adb，并且运行在linux之上稳定性好很多。adb断开连接，不可恢复，脚本退出。
1. 游戏不稳定:SDK部分与UI相关的内容运行在UI主线程，当游戏暂停时可能会出现timeout的情况。如，QQ登录按钮跳转到登录界面，分享按钮，游戏会退出前台主线程暂停。
1. UIAutomator不稳定：UIAutomator并不是一个非常稳定的服务，可能会出现操作无效的情况。


框架本身，只要是框架处理不了的异常，都会抛给调用者。

1. 测试编写的过程中，如果出现操作的内容，可能会让游戏退出前台engine相关接口尽量catch。
1. 对于操作可有可无的，也尽量catch。如点击操作不影响测试流程，如攻击按钮，可以选择catch

&lt;a name="8"&gt;&lt;/a&gt;

# 8 实际使用接口
GAutomator主要的大三类接口engine,reporter，device属于颗粒度非常细的接口，尽可能的原子化，但是直接使用这部分内容进行开发的话，并不是一件容易的事情。所以，根据在实际项目中使用的经验，我们封装了一些更加方便的、易于使用、不容易出错的接口，供开发人员快速的开发出稳定有效的测试用例。
&lt;a name="8.1"&gt;&lt;/a&gt;

## 8.1 screen_shot_click 点击控件截图并记录轨迹
在使用过程中该接口基本，可以替代GameEngine.click。操作流程为截图-&gt;点击的位置标记红点-&gt;点击-&gt;sleep指定的时间，这个操作过程是比较理想的，也是一个最基本的操作。
wetest平台截图的速度非常快，对性能影响也极低，可以对每一个操作步骤均进行截图。
*`screen_shot_click(element, sleeptime=2, exception=False)`*
element:可以为Element实例，也可以为需要点击的name
sleeptime:点击完成后sleep的时间
exception:异常发生时，如果exception为True则抛出异常，如果exception为False则不抛出异常返回False

example:
```python
from testcase.tools import *

button=engine.find_element("LoginQQ")
screen_shot_click(button,sleeptime=5,exception=True)

screen_shot_click("Attack",sleeptime=0)

</code></pre>
<p>截图并标记轨迹如下所示，该部分功能仅限wetest平台测试有效：</p>
<p><a href="image/screen_mark.jpg" target="_blank"><img src="image/screen_mark.jpg" alt="Drawing" width="400px" style="max-width:100%;"></a></p>
<p><a name="8.2"></a></p>
<h2>8.2 screen_shot_click_pos 点击位置截图并记录轨迹</h2>
<p>screen_shot_click_pos与screen_shot_click的区别是，一个点击的是UI控件，一个纯粹是位置信息。操作流程两个是一致的，操作流程为截图-&gt;点击的位置标记红点-&gt;点击-&gt;sleep指定的时间。<br>
<em><code>screen_shot_click_pos(pos_x,pos_y, sleeptime=2, exception=False)</code></em><br>
pos_x:x坐标位置<br>
pos_y:y坐标位置<br>
sleeptime:点击完成后sleep的时间<br>
exception:异常发生时，如果exception为True则抛出异常，如果exception为False则不抛出异常返回False</p>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
